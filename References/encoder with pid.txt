/*****************************************************
  Improved Robot Movement with PID Speed Control
 *****************************************************/

// -------------------------------
// Pin Definitions
// -------------------------------
#define MotFwdA  12  // Motor A Forward pin - left motor
#define MotRevA  14  // Motor A Reverse pin - left motor
#define MotFwdB  25  // Motor B Forward pin - right motor
#define MotRevB  33  // Motor B Reverse pin - right motor
#define STBY     27  // Standby pin
#define PWMA     13  // PWM control for Motor A speed
#define PWMB     26  // PWM control for Motor B speed

// Encoder pins for Motor A
int encoderPinA1 = 35;
int encoderPinA2 = 34;
volatile int lastEncodedA = 0;
volatile long encoderValueA = 0;

// Encoder pins for Motor B
int encoderPinB1 = 15;
int encoderPinB2 = 4;
volatile int lastEncodedB = 0;
volatile long encoderValueB = 0;

// -------------------------------
// PID Parameters
// -------------------------------
float KpA = 1.2;  // Tuned Proportional for Motor A
float KiA = 0.01; // Tuned Integral for Motor A
float KdA = 0.2;  // Tuned Derivative for Motor A

float KpB = 1.2;  // Tuned Proportional for Motor B
float KiB = 0.01; 
float KdB = 0.2;

// State tracking for PID
float errorSumA = 0.0;
float lastErrorA = 0.0;
float errorSumB = 0.0;
float lastErrorB = 0.0;

// Speed tracking
int motorSpeedA = 0;
int motorSpeedB = 0;

// Motor PWM commands
int pwmA = 0;
int pwmB = 0;

// -------------------------------
// Control Constants
// -------------------------------
int targetSpeed = 20;           // [ticks per sample]
float balanceFactor = 1.0;      // Adjust balance between motors
unsigned long pidInterval = 50; // ms between PID checks
unsigned long lastPIDTime = 0;

// -------------------------------
// Setup
// -------------------------------
void setup() {
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);

  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);

  pinMode(MotFwdA, OUTPUT);
  pinMode(MotRevA, OUTPUT);
  pinMode(MotFwdB, OUTPUT);
  pinMode(MotRevB, OUTPUT);

  Serial.begin(115200);

  pinMode(encoderPinA1, INPUT_PULLUP);
  pinMode(encoderPinA2, INPUT_PULLUP);
  pinMode(encoderPinB1, INPUT_PULLUP);
  pinMode(encoderPinB2, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(encoderPinA1), updateEncoderA, CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderPinA2), updateEncoderA, CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderPinB1), updateEncoderB, CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderPinB2), updateEncoderB, CHANGE);

  pwmA = 0;
  pwmB = 0;
  setMotorForward(MotFwdA, MotRevA, PWMA, pwmA);
  setMotorForward(MotFwdB, MotRevB, PWMB, pwmB);
}

// -------------------------------
// Main Loop
// -------------------------------
void loop() {
  unsigned long now = millis();

  if (now - lastPIDTime >= pidInterval) {
    lastPIDTime = now;

    // Calculate speed from encoders
    int deltaA = encoderValueA;
    int deltaB = encoderValueB;

    encoderValueA = 0;
    encoderValueB = 0;

    motorSpeedA = deltaA;
    motorSpeedB = deltaB;

    // Calculate errors
    float errorA = targetSpeed - motorSpeedA;
    float errorB = targetSpeed - motorSpeedB;

    // PID for Motor A
    errorSumA += errorA;
    errorSumA = constrain(errorSumA, -1000, 1000); // Prevent wind-up
    float dErrorA = errorA - lastErrorA;
    lastErrorA = errorA;

    float adjustA = (KpA * errorA) + (KiA * errorSumA) + (KdA * dErrorA);
    pwmA += (int)adjustA;
    pwmA = constrain(pwmA, 0, 255);

    // PID for Motor B
    errorSumB += errorB;
    errorSumB = constrain(errorSumB, -1000, 1000); // Prevent wind-up
    float dErrorB = errorB - lastErrorB;
    lastErrorB = errorB;

    float adjustB = (KpB * errorB) + (KiB * errorSumB) + (KdB * dErrorB);
    pwmB += (int)adjustB * balanceFactor;
    pwmB = constrain(pwmB, 0, 255);

    // Set motors
    setMotorForward(MotFwdA, MotRevA, PWMA, pwmA);
    setMotorForward(MotFwdB, MotRevB, PWMB, pwmB);

    // Debugging
    Serial.print("A_speed: ");
    Serial.print(motorSpeedA);
    Serial.print(", B_speed: ");
    Serial.print(motorSpeedB);
    Serial.print(" | pwmA: ");
    Serial.print(pwmA);
    Serial.print(", pwmB: ");
    Serial.println(pwmB);
  }
  delay(5);
}

// -------------------------------
// Motor Control Helpers
// -------------------------------
void setMotorForward(int fwdPin, int revPin, int pwmPin, int pwmVal) {
  if (pwmVal < 0) {
    digitalWrite(fwdPin, LOW);
    digitalWrite(revPin, HIGH);
    analogWrite(pwmPin, -pwmVal);
  } else {
    digitalWrite(fwdPin, HIGH);
    digitalWrite(revPin, LOW);
    analogWrite(pwmPin, pwmVal);
  }
}

// -------------------------------
// Encoder Update Functions
// -------------------------------
void updateEncoderA() {
  int MSB = digitalRead(encoderPinA1);
  int LSB = digitalRead(encoderPinA2);
  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncodedA << 2) | encoded;

  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderValueA--;
  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderValueA++;
  lastEncodedA = encoded;
}

void updateEncoderB() {
  int MSB = digitalRead(encoderPinB1);
  int LSB = digitalRead(encoderPinB2);
  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncodedB << 2) | encoded;

  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderValueB--;
  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderValueB++;
  lastEncodedB = encoded;
}
